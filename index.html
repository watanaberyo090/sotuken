<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <style>
    body {
      margin: 0;
      padding: 0;
    }
  </style>
</head>

<body>
  <!-- three.jsのcanvas要素を配置するための場所 -->
  <div id="canvas-container"></div>
  <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/",
          "webxr-polyfill": "https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.module.js"
        }
      }
    </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.6/dat.gui.min.js"></script>
  <script src="https://unpkg.com/shpjs@3.5.0/dist/shp.min.js"></script>
  <script type="module">
    // three.jsの読み込み
    import * as THREE from "three";
    // WebVRの判定、遷移ボタンのスクリプト
    import { VRButton } from "three/addons/webxr/VRButton.js";
    // WebXRのポリフィルを読み込み
    import WebXRPolyfill from "webxr-polyfill";
    //コントローラ
    import { XRControllerModelFactory } from 'https://unpkg.com/three@0.150.1/examples/jsm/webxr/XRControllerModelFactory.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.150.1/examples/jsm/controls/OrbitControls.js';
    // カメラの向きを反転するフラグ
    let isRearView = false;
    //コントローラー
    let controller1, controller2;
    let controllerGrip1, controllerGrip2;

    // WebXRのポリフィルを有効にする
    const polyfill = new WebXRPolyfill();

    // サイズを指定
    const width = window.innerWidth;
    const height = window.innerHeight;


    // レンダラーを作成
    let renderer = new THREE.WebGLRenderer({
      antialias: true,
    });
    renderer.setSize(width, height);
    renderer.setPixelRatio(window.devicePixelRatio);

    // レンダラーのWebVR設定を有効にする
    console.log(renderer);
    renderer.xr.enabled = true;

    document.body.appendChild(renderer.domElement);

    // WebVRの開始ボタンをDOMに追加
    document.body.appendChild(VRButton.createButton(renderer));

    // シーンを作成
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xe0ffff);

    // カメラを作成
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);


    // カメラ用コンテナを作成
    const cameraContainer = new THREE.Object3D();
    cameraContainer.position.set(0, 0, 0);
    //右にX60前にZ-150
    cameraContainer.add(camera);
    scene.add(cameraContainer);
    // 後方カメラを作成
    const camera2 = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
    // 後方カメラ用コンテナを作成
    const cameraContainer2 = new THREE.Object3D();
    cameraContainer2.position.set(-6, 10, 0);
    cameraContainer2.rotation.x = -Math.PI / 2;  // -90度回転して真下を向く
    cameraContainer2.updateMatrix();  // ローカル行列を更新
    cameraContainer2.updateMatrixWorld();  // ワールド行列を更新
    cameraContainer2.add(camera2);
    scene.add(cameraContainer2);
    // ミラーとして使用する後方カメラの映像を保存するためのターゲット
    const renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);

    // VR GUIとして表示するHUDの作成 (右上に配置)
    const hudGeometry = new THREE.PlaneGeometry(1, 0.6);  // 1x0.6の平面
    const hudMaterial = new THREE.MeshBasicMaterial({ map: renderTarget.texture });
    const hudScreen = new THREE.Mesh(hudGeometry, hudMaterial);
    // HUDをユーザーの視界の右上に配置
    hudScreen.position.set(0.8, 1.2, -1.5);  // VRカメラの視界内に配置
    scene.add(hudScreen);
    hudScreen.name = "hudScreen";
    // 枠用のジオメトリ (HUDより少し大きい)
    const borderGeometry = new THREE.PlaneGeometry(1.1, 0.7);  // HUDより少し大きくして枠をつける

    // 枠用のマテリアル (色や線の幅を設定)
    const borderMaterial = new THREE.MeshBasicMaterial({ color: 0, side: THREE.DoubleSide });  // 白い枠

    // 枠のメッシュを作成
    const hudBorder = new THREE.Mesh(borderGeometry, borderMaterial);

    // 枠の位置をHUDと同じ位置に設定
    hudBorder.position.copy(hudScreen.position);  // 同じ位置
    hudBorder.quaternion.copy(hudScreen.quaternion);  // 同じ回転
    scene.add(hudBorder);
    // HUDが常にカメラに追従するようにする
    function updateHUDPosition() {
      // カメラの位置を基準にHUDの位置を計算
      const offset = new THREE.Vector3(0.4, 2, -2.5); // 後方視点用のオフセット
      // カメラの位置を基準にHUDの位置を計算
      const offset2 = new THREE.Vector3(0.4, 2.05, -2.6); // 後方視点用のオフセット
      // カメラのクォータニオンをコピー
      const cameraRotation = camera2.quaternion.clone();

      // カメラの回転を適用してHUDの位置を計算
      offset.applyQuaternion(camera.quaternion);
      offset2.applyQuaternion(camera.quaternion);

      // HUDの位置をカメラの位置からオフセットを加えたものに設定
      hudScreen.position.copy(cameraContainer.position).add(offset);
      hudScreen.quaternion.copy(camera.quaternion);
      // HUDの位置をHUDの枠の位置に設定
      hudBorder.position.copy(cameraContainer.position).add(offset2);
      hudBorder.quaternion.copy(camera.quaternion);
    }



    //   光源を作成
    {
      const spotLight = new THREE.SpotLight(
        0xffffff,
        4,
        2000,
        Math.PI / 5,
        0.2,
        1.5
      );
      spotLight.position.set(500, 900, 500);
      scene.add(spotLight);

      const ambientLight = new THREE.AmbientLight(0x333333);
      scene.add(ambientLight);
    }
    //       // GLTF形式のモデルデータを読み込む
    //       const loader2 = new GLTFLoader();
    //       // GLTFファイルのパスを指定
    //       const objects = await loader2.loadAsync("東京23区地図.glb");
    //       // 読み込み後に3D空間に追加
    //       const model = objects.scene;
    //       scene.add(model);
    //     // MTLLoaderでMTLファイルを読み込み
    // const mtlLoader = new MTLLoader();
    // mtlLoader.load("Scene1.mtl", function (materials) {
    //     materials.preload();

    //     // OBJLoaderでOBJファイルを読み込み
    //     const objLoader = new OBJLoader();
    //     objLoader.setMaterials(materials);
    //     objLoader.load("Scene1.obj", function (object) {
    //         scene.add(object);
    //     });
    // });

    // シェープファイルのデータを読み込み、GeoJSONとして表示
    // function loadShapefile(url) {
    //   shp(url).then(function (geojson) {
    //     geojson.features.forEach(feature => {
    //       const coordinates = feature.geometry.coordinates;
    //       coordinates.forEach(coord => {
    //         const [lon, lat] = coord;

    //         // ピンとして表示するためのジオメトリとマテリアルを作成
    //         const pinGeometry = new THREE.ConeGeometry(0.01, 0.05, 32);
    //         const pinMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    //         const pin = new THREE.Mesh(pinGeometry, pinMaterial);

    //         // 座標をThree.jsの位置に変換（仮にそのまま使用）
    //         pin.position.set(lon, 0.025, -lat);
    //         scene.add(pin);
    //       });
    //     });
    //   });
    // }

    // // シェープファイルを指定したURLからロード
    // loadShapefile('A40-20_14.GML.zip');



    let hasExecuted = false;//一度のみ処理するための変数
    let marker5;//前のフレームのマーカーの座標を保持
    let zoomed = 0;//前のフレームのzoom値を保持する
    let x;//前のフレームのマーカーx座標を保持する
    let z;//前のフレームのマーカーz座標を保持する
    let tileOriginX;//地図のｘ座標
    let tileOriginY;//地図のｙ座標
    let coordinates;//マーカーの座標を経度緯度に変換して保持する
    let centerTile;//中心座標
    let zoom = 19;//地図のズームレベル
    let centerLon = 139.7454; // 東京都心の経度
    let centerLat = 35.6586;   // 東京都心の緯度
    // 神奈川35.481666902138336, 139.35879951675716
    //東京35.689,139.6917
    // タイルメッシュを保持する配列
    let tiles = [];//全ての地図タイルを管理する配列
    let pins = []; // すべてのピンを管理する配列
    let lines = [];//すべての経路を管理する配列
    let builds = [];//すべての建物を管理する配列
    // 出発地点と目的地点の緯度経度を定義
    const startLat = 35.6895; // 出発地点の緯度 (例: 東京)
    const startLon = 139.6917; // 出発地点の経度 (例: 東京)
    const endLat = 35.6586; // 目的地点の緯度 (例: 東京タワー)
    const endLon = 139.7454; // 目的地点の経度 (例: 東京タワー)
    // OSRM APIのURLを構築

    // ピン（Marker）オブジェクトを作成する
    const geometry1 = new THREE.CylinderGeometry(0.1, 0.1, 5, 32);  // 半径0.1、高さ0.2、32セグメントの円柱
    const material1 = new THREE.MeshBasicMaterial({ color: 0x9acd32 });  // 色を設定（黒）
    let marker1 = new THREE.Mesh(geometry1, material1);
    marker1.position.set(0.48421333333408256, 0.5, -3.0365134467951975);  // 東京タワーの緯度経度をthree.js座標に変えたもの

    marker1.name = "marker1";
    scene.add(marker1);

    let marker2 = new THREE.Mesh(geometry1, material1);
    marker2.position.set(0.8, 0.5, -0.5);  // VRカメラの視界内に配置
    marker2.name = "marker2";
    scene.add(marker2);
    //中心座標を表すobject
    const geometry2 = new THREE.CylinderGeometry(0.2, 0.2, 0.4, 32);
    const material2 = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    let cylinder = new THREE.Mesh(geometry2, material2);
    cylinder.position.set(0.48421333333408256, 0.5, -3.0365134467951975);   // 東京タワーの緯度経度をthree.js座標に変えたもの
    //scene.add(cylinder);
    function map() {
      const loader = new THREE.TextureLoader();
      const osmUrl = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
      //地図中心座標
      if (coordinates == undefined) {
        console.log("A");
        centerTile = lonLatToTileXY(endLon, endLat, zoom);
        tileOriginX = Math.floor(centerTile.x) - 2;
        tileOriginY = Math.floor(centerTile.y) - 2;

        console.log(convertCoordinates(endLon, endLat));
      } else {
        //マーカーの座標を経度緯度に変換して保持するcoordinatesを更新
        if (marker5 == undefined) { } else if (marker5.name == "marker1") {
          console.log("gs");
          //マーカ1を動かした際に変更
          coordinates = getMarkerCoordinates(marker5, marker2, zoom);
        } else if (marker5.name == "marker2") {
          //マーカ2を動かした際に変更
          coordinates = getMarkerCoordinates(marker1, marker5, zoom);
        }
        console.log("a");
        x = coordinates.start.lon;
        z = coordinates.start.lat;
        centerTile = lonLatToTileXY(coordinates.start.lon, coordinates.start.lat, zoom);
        tileOriginX = Math.floor(centerTile.x) - 2;
        tileOriginY = Math.floor(centerTile.y) - 2;
      }


      // タイルを複数ロード
      for (let x = tileOriginX - (26 - zoom); x < tileOriginX + 5; x++) {
        for (let y = tileOriginY - (10 - Math.floor(zoom / 3)); y < tileOriginY + 19; y++) {

          loadOSMTile(x, y, zoom);


        }
      }
      // タイルをロードする関数
      function loadOSMTile(x, y, z) {
        const subdomain = ['a', 'b', 'c'][Math.floor(Math.random() * 3)];
        const url = osmUrl.replace('{s}', subdomain).replace('{z}', z).replace('{x}', x).replace('{y}', y);

        loader.load(url, function (texture) {
          const geometry = new THREE.PlaneGeometry(1, 1);
          const material = new THREE.MeshBasicMaterial({ map: texture });
          const tile = new THREE.Mesh(geometry, material);
          tile.rotation.x = -Math.PI / 2;
          tile.position.set((x - 2 - tileOriginX), 0, (y - 5 - tileOriginY));

          // タイルを配列に追加
          tiles.push(tile);
          scene.add(tile);
        }, undefined, function (err) {
          console.error('タイルの読み込みに失敗しました:', err);
        });
      }



      // 緯度経度をタイル座標に変換する関数
      function lonLatToTileXY(lon, lat, zoom) {
        const tileCount = Math.pow(2, zoom);
        const x = ((lon + 180) / 360) * tileCount;
        const y = (1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * tileCount;
        return { x, y };
      }

      // 緯度経度をThree.jsのシーン座標に変換する関数
      function convertCoordinates(lon, lat) {
        const tile = lonLatToTileXY(lon, lat, zoom);

        // マップの中心となるタイルを基準にオフセットを計算
        const xOffset = tile.x - tileOriginX;
        const yOffset = tile.y - tileOriginY;

        // Three.js の空間でのタイルの大きさに合わせたスケールファクター (タイル幅の0.5単位)
        const tileScale = 0.7;

        // スケールを適用して座標を計算
        const x = (tile.x - 2.5 - tileOriginX);
        const z = (tile.y - 5.5 - tileOriginY);


        return { x, z };
      }
      // Three.jsのシーン座標を緯度経度に戻す関数
      function convertSceneToLatLon(x, z, zoom) {
        // Three.jsの座標に適用されていたスケーリングを逆にする
        const tileScale = 0.7;

        // Three.jsのシーン座標をタイル座標に戻す
        const tileX = (x + tileOriginX) + 2.5;
        const tileY = (z + tileOriginY) + 5.5;

        // タイル座標から緯度経度を計算する
        const lonLat = tileXYToLonLat(tileX, tileY, zoom);

        return { lon: lonLat.lon, lat: lonLat.lat };
      }

      // これは `lonLatToTileXY` の逆変換を行う関数です
      function tileXYToLonLat(tileX, tileY, zoom) {
        const n = Math.PI - 2 * Math.PI * tileY / Math.pow(2, zoom);
        const lon = tileX / Math.pow(2, zoom) * 360 - 180;
        const lat = (180 / Math.PI) * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));

        return { lon, lat };
      }

      // マーカーの座標を返す関数
      function getMarkerCoordinates(startMarker, endMarker, zoom) {
        const startPosition = convertSceneToLatLon(startMarker.position.x, startMarker.position.z, zoom);
        const endPosition = convertSceneToLatLon(endMarker.position.x, endMarker.position.z, zoom);

        return {
          start: startPosition,
          end: endPosition
        };
      }

      // マーカーの前のフレームの座標を上書きするのとOSRM APIのURLを構築する関数
      function createOSRMRoute(startMarker, endMarker, zoom) {
        if (!hasExecuted) {
          console.log("このコードは一度だけ実行されます。");
          // ここに実行したいコードを書く
          coordinates = getMarkerCoordinates(startMarker, endMarker, zoom);
          // フラグを更新
          hasExecuted = true;
        }

        const marker3 = convertCoordinates(coordinates.start.lon, coordinates.start.lat);
        marker1.position.set(marker3.x, 2.5, marker3.z);  // VRカメラの視界内に配置
        const marker4 = convertCoordinates(coordinates.end.lon, coordinates.end.lat);

        marker2.position.set(marker4.x, 2.5, marker4.z);  // VRカメラの視界内に配置
        coordinates = getMarkerCoordinates(startMarker, endMarker, zoom);
        marker5 = undefined;
        const startLon = coordinates.start.lon;
        const startLat = coordinates.start.lat;
        const endLon = coordinates.end.lon;
        const endLat = coordinates.end.lat;
        // OSRM APIのURLを構築
        const url = `https://router.project-osrm.org/route/v1/driving/${startLon},${startLat};${endLon},${endLat}?overview=full&geometries=geojson`;

        console.log('OSRM API URL:', url);
        return url; // 必要に応じてURLを返す
      }

      // function calculatePinSize(zoom) {
      //   let size;
      //   if (zoom > 12) {
      //     size = 0.002;
      //   } else size = 0.002
      //   return size;
      // }

      // function loadShapefile(url) {

      //   // シェープファイルをロードしてピンを再表示
      //   shp(url).then(function (geojson) {
      //     geojson.features.forEach(feature => {
      //       //console.log(JSON.stringify(feature, null, 2));
      //       if (feature.geometry.type === 'Point') {
      //         const [lon, lat] = feature.geometry.coordinates;
      //         if (isWithinTileBounds(lon, lat)) {
      //           const pos = convertCoordinates(lon, lat);
      //           const pinsize = calculatePinSize(zoom);
      //           const pinGeometry = new THREE.CylinderGeometry(pinsize, pinsize, 0.5);
      //           const pinMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
      //           const pin = new THREE.Mesh(pinGeometry, pinMaterial);

      //           pin.position.set(pos.x, 0.025, pos.z);

      //           scene.add(pin); // シーンにピンを追加
      //           pins.push(pin); // 配列にピンを追加して追跡
      //         }
      //       }
      //       // ポリゴンやラインの処理も必要に応じて追加
      //     });

      //     console.log("シェープファイルのデータをロードしました");
      //   }).catch(function (error) {
      //     console.error("シェープファイルの読み込みに失敗しました:", error);
      //   });
      // }
      // // タイルの範囲内に座標があるかを確認する関数
      // function isWithinTileBounds(lon, lat) {
      //   const tileNW = tileToLonLat(tileOriginX - (26 - zoom), tileOriginY - (10 - Math.floor(zoom / 3)), zoom); // 左上
      //const tileSE = tileToLonLat(tileOriginX + 5, tileOriginY + 19, zoom); // 右下

      //   return (
      //     lon >= tileNW.lon && lon <= tileSE.lon && // 経度が範囲内
      //     lat <= tileNW.lat && lat >= tileSE.lat    // 緯度が範囲内
      //   );
      // }

      // タイル座標から緯度経度に変換する関数
      function tileToLonLat(x, y, zoom) {
        const n = Math.pow(2, zoom);
        const lon = ((x / n) * 360 - 180);
        const lat = Math.atan(Math.sinh(Math.PI * (1 - (2 * y) / n))) * (180 / Math.PI);
        return { lon, lat };
      }
      // // シェープファイルのパスを指定（.zip形式）
      // loadShapefile('P29-13_14.zip'); // 実際のURLに置き換えてください

      //経路探索
      const routeUrl = createOSRMRoute(marker1, marker2, zoom);
      // 経路データを取得
      fetch(routeUrl)
        .then(response => response.json())
        .then(data => {
          // 経路情報を取得
          const route = data.routes[0].geometry.coordinates;
          displayRouteOnMap(route);

        })
        .catch(error => console.error('Error fetching route:', error));
      // 取得した経路を表示する (地図表示の関数)
      function displayRouteOnMap(route) {
        console.log("経路を表示:", route);

        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff }); // 経路を青色で表示
        const points = [];

        // 経路データをThree.jsの座標に変換
        route.forEach(coord => {
          const lon = coord[0];
          const lat = coord[1];
          const { x, z } = convertCoordinates(lon, lat);  // 緯度経度をThree.jsの座標系に変換
          points.push(new THREE.Vector3(x, 0.05, z));  // Y軸を0.01に設定して地面から少し浮かせる
        });

        const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(lineGeometry, lineMaterial);
        scene.add(line);
        lines.push(line);
      }
      //建物表示
      function loadBuildings(bounds) {
        // Overpass APIクエリ (指定範囲内の建物を取得)
        const query = `
        [out:json];
        (way["building"](${bounds.south},${bounds.west},${bounds.north},${bounds.east});
         relation["building"](${bounds.south},${bounds.west},${bounds.north},${bounds.east}););
        out tags geom;`;

        const url = "https://overpass-api.de/api/interpreter?data=" + encodeURIComponent(query);

        fetch(url)
          .then(response => response.json())
          .then(data => {
            // 建物データをThree.jsオブジェクトとして追加
            data.elements.forEach(element => {
              if (element.type === "way" && element.geometry) {
                const shape = new THREE.Shape();

                // 建物のポリゴン座標をThree.js座標に変換
                element.geometry.forEach((point, index) => {
                  const coords = convertCoordinates(point.lon, point.lat);
                  if (index === 0) {
                    shape.moveTo(coords.x, -coords.z);
                  } else {
                    shape.lineTo(coords.x, -coords.z);
                  }
                });

                // 建物の高さを取得
                const height = getBuildingHeight(element.tags);

                // ポリゴンを3Dオブジェクトに変換
                const geometry = new THREE.ExtrudeGeometry(shape, { depth: height, bevelEnabled: false });
                const material = new THREE.MeshStandardMaterial({ color: 0x999999, side: THREE.DoubleSide });
                const building = new THREE.Mesh(geometry, material);
                building.rotation.x = -Math.PI / 2; //x中心に回転

                builds.push(building);
                // シーンに追加
                scene.add(building);
              }
            });
          })
          .catch(error => console.error('Error loading buildings:', error));
      }

      // 建物の高さを取得する関数
      function getBuildingHeight(tags) {
        if (tags.height) {
          return parseFloat(tags.height * 0.05); // OSMのheightタグを使用
        } else if (tags["building:levels"]) {
          const levels = parseInt(tags["building:levels"], 10);
          return levels * 0.1; // 1階を0.1メートルとして換算
        } else {
          return 0.1; // デフォルトの高さ（0.1メートル）を使用
        }
      }

      // 地図範囲を取得して建物をロード
      function updateBuildings(center, zoom) {
        // 地図範囲を計算
        const tileNW = tileToLonLat(tileOriginX - (26 - zoom), tileOriginY - (10 - Math.floor(zoom / 3)), zoom); // 左上
        const tileSE = tileToLonLat(tileOriginX + 5, tileOriginY + 19, zoom); // 右下


        const bounds = {
          north: tileNW.lat,
          south: tileSE.lat,
          east: tileSE.lon,
          west: tileNW.lon,
        };

        loadBuildings(bounds);
      }
      console.log(zoom);
      //zoomが一番拡大されたときのみ建物を表示
      if (zoom > 18) {
        // 中心座標変更時に呼び出す
        updateBuildings({ lon: centerLon, lat: centerLat }, zoom);
      }
    }
    map();


    // タイル、ピン、経路、建物を削除する関数
    function clear() {
      tiles.forEach(tile => {
        scene.remove(tile); // シーンからタイルを削除
      });
      tiles = []; // 配列をクリア
      pins.forEach(pin => {
        scene.remove(pin);  // シーンからピンを削除
        pins = [];
      });
      pins = []; // 配列をクリア
      lines.forEach(line => {
        scene.remove(line); // シーンから経路を削除
      });
      lines = []; // 配列をクリア
      builds.forEach(line => {
        scene.remove(line); // シーンから経路を削除
      });
      builds = []; // 配列をクリア
    }
    // 毎フレーム時に実行されるループイベント
    function tick() {
      //updateHUDPosition();  // HUDの位置を更新
      if (isRearView) {
        renderer.xr.enabled = true;//カメラの回転を有効
        cameraContainer.position.y = 10;
        renderer.render(scene, camera);  // メインカメラでVRシーンを描画
        cameraContainer2.position.set(-6 + (-13 / 2 + zoom / 2), 26 - zoom, 0);

        cameraContainer2.rotation.x = -Math.PI / 2;  // -90度回転して真下を向く   
        renderer.setRenderTarget(renderTarget);  // 後方カメラ用のレンダリングターゲットをセット
        renderer.xr.enabled = false;//カメラの回転を無効
        renderer.render(scene, camera2);  // 後方カメラでVRシーンを描画
        renderer.setRenderTarget(null);  // ターゲットを元に戻す
        updateHUDPosition();  // HUDの位置を更新

      } else {
        renderer.xr.enabled = true;//カメラの回転を有効

        cameraContainer.position.y = 0;
        renderer.render(scene, camera);  // メインカメラでVRシーンを描画
        cameraContainer2.position.set(-6 + (-13 / 2 + zoom / 2), 26 - zoom, 0);

        cameraContainer2.rotation.x = -Math.PI / 2;  // -90度回転して真下を向く   
        renderer.setRenderTarget(renderTarget);  // 後方カメラ用のレンダリングターゲットをセット
        renderer.xr.enabled = false;//カメラの回転を無効
        renderer.render(scene, camera2);  // 後方カメラでVRシーンを描画
        renderer.setRenderTarget(null);  // ターゲットを元に戻す
        updateHUDPosition();  // HUDの位置を更新

      }
    }


    // リサイズ処理
    window.addEventListener("resize", onResize);
    function onResize() {
      if (!renderer.xr.getSession()) { // Only resize if not in VR
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    }

    /* ----コントローラー設定----- */

    // コントローラーイベントの設定
    function onSelectStart() {
      this.userData.isSelecting = true;
    }
    function onSelectEnd() {
      this.userData.isSelecting = false;
    }
    function onButtonDown() {
      this.userData.isSelecting = true;
    }
    function onButtonUp() {
      this.userData.isSelecting = false;
    }
    function onSqueezeStart() {
      this.userData.isSelecting = true;
    }
    function onSqueezeEnd() {
      this.userData.isSelecting = false;
    }
    //コントローラー取得
    //前方コントローラ
    controller1 = renderer.xr.getController(0);
    controller1.addEventListener('selectstart', onSelectStart);//トリガー
    controller1.addEventListener('selectend', onSelectEnd);
    controller1.addEventListener('squeezestart', onSqueezeStart);//スクイーズ
    controller1.addEventListener('squeezeend', onSqueezeEnd);
    controller1.addEventListener('connected', (event) => {
      if ('gamepad' in event.data) {//接続した際にコントローラの情報を渡す
        if ('axes' in event.data.gamepad) {
          controller1.gamepad = event.data.gamepad;
        }
      }
    });
    controller2 = renderer.xr.getController(1);
    controller2.addEventListener('selectstart', onSelectStart);//トリガー
    controller2.addEventListener('selectend', onSelectEnd);
    controller2.addEventListener('squeezestart', onSqueezeStart);//スクイーズ
    controller2.addEventListener('squeezeend', onSqueezeEnd);
    controller2.addEventListener('connected', (event) => {
      if ('gamepad' in event.data) {
        if ('axes' in event.data.gamepad) {
          controller2.gamepad = event.data.gamepad;
        }
      }
    });

    //コントローラーモデルを取得
    const controllerModelFactory = new XRControllerModelFactory();
    controllerGrip1 = renderer.xr.getControllerGrip(0);
    controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));

    controllerGrip2 = renderer.xr.getControllerGrip(1);
    controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
    // Set positions for controllers
    controller1.position.set(0.5, 200, 0.5); // Example position for controller1
    controller2.position.set(-0.5, 200, 0.5); // Example position for controller2
    // コントローラーに userData プロパティを追加して id を設定する
    controller1.userData.id = 0;
    controller2.userData.id = 1;
    //コントローラーから出る光線の作成				
    const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]);
    const line1 = new THREE.Line(geo);
    const line2 = new THREE.Line(geo);
    line1.name = 'line';
    line1.scale.z = 5;
    line2.name = 'line';
    line2.scale.z = 5;
    controller1.add(line1.clone());
    controller2.add(line2.clone());

    //コントローラ機能


    // Raycasterを作成
    let raycaster = new THREE.Raycaster();
    let tempMatrix = new THREE.Matrix4(); // コントローラーの位置と向きを取得するための一時行列
    var groupsToIntersect = [hudScreen, marker1, marker2];//レイと交差判定できるobjectを代入
    // レイと交差しているシェイプの取得
    function getIntersections(controller) {
      tempMatrix.identity().extractRotation(controller.matrixWorld);
      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
      return raycaster.intersectObjects(groupsToIntersect, true);
    }
    let hasZoomed1 = true; // ボタンを押した状態を追跡するフラグ
    let hasZoomed2 = true; // ボタンを押した状態を追跡するフラグ
    // レイキャスターの原点（コントローラーの位置）を格納するVector3
    const rayOrigin = new THREE.Vector3();
    function handleController(controller) {
      const controllerData = controller.gamepad;
      //console.log(controllerData);
      const userData = controller.userData;
      const intersections = getIntersections(controller);//当たり判定
      //console.log(intersections);
      if (userData.isSelecting === true) {
        if (controllerData.buttons[0].pressed == true) {//トリガーボタン
          if (userData.id == 0) {
            line1.material.color.set(0xff0000); // 赤色に設定

            if (intersections.length > 0) {
              const intersection = intersections[0];
              const object = intersection.object;
              if (object.name == "marker1" || object.name == "marker2") {
                // 動かす前の座標を保存
                const originalPosition = { x: object.position.x, y: object.position.y, z: object.position.z };

                // オブジェクトの座標をコントローラーにアタッチ
                controller.attach(object);

                // コントローラーのユーザーデータに選択されたオブジェクトを保存
                controller.userData.selected = object;
              }
            }
          } else {
            line2.material.color.set(0xff0000);
            if (intersections.length > 0) {
              const intersection = intersections[0];
              const object = intersection.object;
              if (object.name == "marker1" || object.name == "marker2") {
                // 動かす前の座標を保存
                const originalPosition = { x: object.position.x, y: object.position.y, z: object.position.z };

                // オブジェクトの座標をコントローラーにアタッチ
                controller.attach(object);

                // コントローラーのユーザーデータに選択されたオブジェクトを保存
                controller.userData.selected = object;
              }
            }
          }
        } else if (controllerData.buttons[1].pressed == true) {//スクイーズボタン
          if (userData.id == 0) {
            line1.material.color.set(0xff0000); // 赤色に設定
            if (intersections.length > 0 && intersections[0].object.name == "hudScreen" && !isRearView && hasZoomed1) {//カメラ切り替え
              isRearView = true;
              hasZoomed1 = false;
              console.log("isrear");
            } else if (isRearView == true && hasZoomed1) {//カメラ切り替え
              isRearView = false;
              hasZoomed1 = false;
              console.log("isrear");
            } else if (hasZoomed1 && zoom < 19) {//地図拡大
              zoom += 3;
              clear();
              map();
              hasZoomed1 = false;
            }
          } else {
            line2.material.color.set(0xff0000); // 赤色に設定
            if (intersections.length > 0 && intersections[0].object.name == "hudScreen" && !isRearView && hasZoomed2) {//カメラ切り替え
              isRearView = true;
              hasZoomed2 = false;
              console.log("isrear");
            } else if (isRearView == true && hasZoomed2) {//カメラ切り替え
              isRearView = false;
              hasZoomed2 = false;
              console.log("isrear");
            } else if (hasZoomed2 && zoom > 7) {//地図縮小
              zoom -= 3;
              clear();
              map();
              hasZoomed2 = false;
            }
          }
        }

      } else if (userData.id == 0) {
        //右ボタンが離されたときの処理
        line1.material.color.set(0xffffff); hasZoomed1 = true; //白色に設定
        if (controller.userData.selected !== undefined) {
          const object = controller.userData.selected;

          object.matrix.premultiply(controller.matrixWorld);
          object.matrix.decompose(object.position, object.quaternion, object.scale);
          marker5 = object;
          scene.add(object);
          controller.userData.selected = undefined;
          clear();
          map();
        }
      } else {
        //左ボタンが離されたときの処理
        line2.material.color.set(0xffffff); hasZoomed2 = true
        if (controller.userData.selected !== undefined) {
          const object = controller.userData.selected;
          object.matrix.premultiply(controller.matrixWorld);
          object.matrix.decompose(object.position, object.quaternion, object.scale);
          marker5 = object;
          scene.add(object);
          controller.userData.selected = undefined;
          clear();
          map();
        }
      }
    }
    const speed = 0.05;
    // スティック入力に基づく移動
    function updateMovement1(controller) {
      // コントローラのゲームパッドデータを取得
      const controllerData = controller.gamepad;

      if (controllerData && controllerData.axes) {
        const joystickInput = controllerData.axes; // スティックの入力
        // スティックの入力がゼロでないかを確認
        if (Math.abs(joystickInput[2]) > 0.1 || Math.abs(joystickInput[3]) > 0.1) {
          cameraContainer.position.x += joystickInput[2] * speed;
          cameraContainer.position.z += joystickInput[3] * speed;
          cameraContainer2.position.x += joystickInput[2] * speed;
          cameraContainer2.position.z += joystickInput[3] * speed;

        }
      }
    }




    /* ----コントローラー設定----- */



    // レンダラーにループ関数を登録
    //renderer.setAnimationLoop(tick);
    // フラストムを生成
    const frustum = new THREE.Frustum();
    const cameraViewProjectionMatrix = new THREE.Matrix4();
    const frustum2 = new THREE.Frustum();
    const cameraViewProjectionMatrix2 = new THREE.Matrix4();

    function updateVisibleTiles() {
      // カメラのビュー投影行列を更新
      camera.updateMatrixWorld(); // ワールドマトリクスを更新
      cameraViewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      frustum.setFromProjectionMatrix(cameraViewProjectionMatrix);
      camera2.updateMatrixWorld(); // ワールドマトリクスを更新
      cameraViewProjectionMatrix2.multiplyMatrices(camera2.projectionMatrix, camera2.matrixWorldInverse);
      frustum2.setFromProjectionMatrix(cameraViewProjectionMatrix2);

      tiles.forEach(tile => {
        // タイルのボックスを生成
        const box = new THREE.Box3().setFromCenterAndSize(tile.position, new THREE.Vector3(1, 1, 1));

        // タイルがフラストム内にあるかを確認
        if (frustum.intersectsBox(box) || frustum2.intersectsBox(box)) {
          // フラストム内の場合はシーンに追加
          if (!scene.children.includes(tile)) {
            scene.add(tile);
          }
        } else {
          // フラストム外の場合はシーンから削除
          if (scene.children.includes(tile)) {
            scene.remove(tile);
          }
        }
      });
    }
    //毎フレーム実行される
    function render() {
      //カメラ切り替え
      tick();
      //スティック移動
      updateMovement1(controller1);
      updateMovement1(controller2);
      //カメラに写っている範囲のみ地図を表示
      //updateVisibleTiles();
      //前方後方コントローラ切り替え

      cameraContainer.add(controller1);
      cameraContainer.add(controller2);
      cameraContainer.add(controllerGrip1);
      cameraContainer.add(controllerGrip2);

      //コントローラ機能
      handleController(controller1);
      handleController(controller2);
    }
    // 初回のレンダリングループの開始
    renderer.setAnimationLoop(render);
  </script>
</body>

</html>
