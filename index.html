<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>VR駅別乗降客数可視化</title>
  <style>
    body {
      margin: 0;
      padding: 0;
    }
  </style>
</head>

<body>
  <!-- three.jsのcanvas要素を配置するための場所 -->
  <div id="canvas-container"></div>
  <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/",
          "webxr-polyfill": "https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.module.js"
        }
      }
    </script>
  <script src="https://unpkg.com/shpjs@3.5.0/dist/shp.min.js"></script>
  <script type="module">
    //建物比較
    // three.jsの読み込み
    import * as THREE from "three";
    // WebVRの判定、遷移ボタンのスクリプト
    import { VRButton } from "three/addons/webxr/VRButton.js";
    // WebXRのポリフィルを読み込み
    import WebXRPolyfill from "webxr-polyfill";
    //コントローラ
    import { XRControllerModelFactory } from 'https://unpkg.com/three@0.150.1/examples/jsm/webxr/XRControllerModelFactory.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.150.1/examples/jsm/controls/OrbitControls.js';
    // カメラの向きを反転するフラグ
    let isRearView = false;
    //コントローラー
    let controller1, controller2;
    let controllerGrip1, controllerGrip2;

    // WebXRのポリフィルを有効にする
    const polyfill = new WebXRPolyfill();

    // サイズを指定
    const width = window.innerWidth;
    const height = window.innerHeight;


    // レンダラーを作成
    let renderer = new THREE.WebGLRenderer({
      antialias: true,
    });
    // renderer.shadowMap.enabled = true;        // 影の有効化
    renderer.setSize(width, height);
    renderer.setPixelRatio(window.devicePixelRatio);

    // レンダラーのWebVR設定を有効にする
    renderer.xr.enabled = true;

    document.body.appendChild(renderer.domElement);

    // WebVRの開始ボタンをDOMに追加
    document.body.appendChild(VRButton.createButton(renderer));

    // シーンを作成
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xe0ffff);

    // カメラを作成
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 30);


    // カメラ用コンテナを作成
    const cameraContainer = new THREE.Object3D();
    cameraContainer.position.set(0, 1, 0);
    //右にX60前にZ-150

    cameraContainer.add(camera);

    scene.add(cameraContainer);
    // 後方カメラを作成
    const camera2 = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 30);
    // 後方カメラ用コンテナを作成
    const cameraContainer2 = new THREE.Object3D();
    cameraContainer2.position.set(0, 2, 105);
    // cameraContainer2.rotation.y = Math.PI;  // 前方を向くように回転
    //右にX60前にZ-150
    cameraContainer2.add(camera2);
    scene.add(cameraContainer2);
    // ミラーとして使用する後方カメラの映像を保存するためのターゲット
    const renderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight);

    // VR GUIとして表示するHUDの作成 (右上に配置)
    const hudGeometry = new THREE.PlaneGeometry(1, 0.6);  // 1x0.6の平面
    const hudMaterial = new THREE.MeshBasicMaterial({ map: renderTarget.texture });
    const hudScreen = new THREE.Mesh(hudGeometry, hudMaterial);
    // HUDをユーザーの視界の右上に配置
    hudScreen.position.set(0.8, 1.2, -1.5);  // VRカメラの視界内に配置
    hudScreen.name = "hudScreen";
    // 枠用のジオメトリ (HUDより少し大きい)
    const borderGeometry = new THREE.PlaneGeometry(1.1, 0.7);  // HUDより少し大きくして枠をつける

    // 枠用のマテリアル (色や線の幅を設定)
    const borderMaterial = new THREE.MeshBasicMaterial({ color: 0, side: THREE.DoubleSide });  // 白い枠

    // 枠のメッシュを作成
    const hudBorder = new THREE.Mesh(borderGeometry, borderMaterial);

    // 枠の位置をHUDと同じ位置に設定
    hudBorder.position.copy(hudScreen.position);  // 同じ位置
    hudBorder.quaternion.copy(hudScreen.quaternion);  // 同じ回転
    // テキストを描画するためのキャンバスを作成
    let year = 2012;
    const canvas3 = document.createElement('canvas');
    const context3 = canvas3.getContext('2d');
    context3.font = '30px Arial';
    context3.fillStyle = 'red';
    context3.fillText(year + "年", 10, 50); // 高さのテキスト

    // CanvasTextureを作成し、Spriteを作成（最初に一度だけ）
    const texture3 = new THREE.CanvasTexture(canvas3);
    const spriteMaterial3 = new THREE.SpriteMaterial({
      map: texture3,
      side: THREE.DoubleSide,  // 両面描画
      depthTest: false,         // 深度テストを無効に
      depthWrite: false         // 深度書き込みを無効に
    });
    const sprite3 = new THREE.Sprite(spriteMaterial3);
    //sprite3.position.set(1,1,-5);
    const canvas4 = document.createElement('canvas');
    const context4 = canvas4.getContext('2d');
    context4.font = '100px Arial';
    context4.fillStyle = 'red';
    context4.fillText(year + "年", 0, 100); // 高さのテキスト
    // CanvasTextureを作成し、Spriteを作成（最初に一度だけ）
    const texture4 = new THREE.CanvasTexture(canvas4);
    const spriteMaterial4 = new THREE.SpriteMaterial({
      map: texture4,
      side: THREE.DoubleSide,  // 両面描画
      depthTest: false,         // 深度テストを無効に
      depthWrite: false         // 深度書き込みを無効に
    });
    const sprite4 = new THREE.Sprite(spriteMaterial4);
    // HUDグループを作成して関連オブジェクトを追加
    const hudGroup = new THREE.Group();
    hudGroup.add(hudScreen);
    hudGroup.add(hudBorder);
    hudGroup.add(sprite3);
    scene.add(hudGroup);

    // HUDの初期状態を設定
    hudGroup.visible = true; // 表示状態
    // HUDが常にカメラに追従するようにする
    function updateHUDPosition() {
      // カメラの位置を基準にHUDの位置を計算
      const offset = new THREE.Vector3(0.4, 2, -2.5); // 後方視点用のオフセット
      // カメラの位置を基準にHUDの位置を計算
      const offset2 = new THREE.Vector3(0.4, 2.05, -2.6); // 後方視点用のオフセット
      const offset3 = new THREE.Vector3(1.5, 2, -2.5); // 後方視点用のオフセット
      // カメラのクォータニオンをコピー
      const cameraRotation = camera.quaternion.clone();


      if (isRearView) {

        // カメラの回転を適用してHUDの位置を計算
        offset.applyQuaternion(camera2.quaternion);
        offset2.applyQuaternion(camera2.quaternion);

        offset3.applyQuaternion(camera2.quaternion);
        // HUDの位置をカメラの位置からオフセットを加えたものに設定
        hudScreen.position.copy(cameraContainer2.position).add(offset);
        hudScreen.quaternion.copy(camera2.quaternion);
        // HUDの位置をHUDの枠の位置に設定
        hudBorder.position.copy(cameraContainer2.position).add(offset2);
        hudBorder.quaternion.copy(camera2.quaternion);
        sprite3.position.copy(cameraContainer2.position).add(offset3);
        sprite3.rotation.copy(camera2.rotation);

      } else {
        // カメラの回転を適用してHUDの位置を計算
        offset.applyQuaternion(camera.quaternion);
        offset2.applyQuaternion(camera.quaternion);
        offset3.applyQuaternion(camera.quaternion);

        // HUDの位置をカメラの位置からオフセットを加えたものに設定
        hudScreen.position.copy(cameraContainer.position).add(offset);
        hudScreen.quaternion.copy(camera.quaternion);
        // HUDの位置をHUDの枠の位置に設定
        hudBorder.position.copy(cameraContainer.position).add(offset2);
        hudBorder.quaternion.copy(camera.quaternion);

        sprite3.position.copy(cameraContainer.position).add(offset3);
        sprite3.rotation.copy(camera.rotation);

      }
    }



    // 光源の作成
    const spotLight = new THREE.DirectionalLight(
      0xffffff,
      1,        // 光の強さ
    );
    spotLight.position.set(500, 900, 500);
    scene.add(spotLight);

    // // 周囲の光源 (Ambient Light)
    const ambientLight = new THREE.AmbientLight(0x333333);
    scene.add(ambientLight);

    const loader = new THREE.TextureLoader();
    const osmUrl = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
    let hasExecuted = false;//一度のみ処理するための変数
    let marker5;//前のフレームのマーカーの座標を保持
    let zoomed = 0;//前のフレームのzoom値を保持する
    let x;//前のフレームのマーカーx座標を保持する
    let z;//前のフレームのマーカーz座標を保持する
    let tileOriginX;//地図のｘ座標
    let tileOriginY;//地図のｙ座標
    let coordinates;//マーカーの座標を経度緯度に変換して保持する
    let coordinates2;//中心の円柱の座標を経度緯度に変換して保持する
    let centerTile;//中心座標
    let zoom = 19;//地図のズームレベル
    let centerLon = 139.7454; // 東京都心の経度
    let centerLat = 35.6586;   // 東京都心の緯度
    let Execute = true //カメラ２を停止するための変数
    let hour = 1;//太陽の位置
    // タイルメッシュを保持する配列
    let tiles = [];//全ての地図タイルを管理する配列
    let pins = []; // すべてのピンを管理する配列
    let lines = [];//すべての経路を管理する配列
    let builds = [];//すべての建物を管理する配列
    // 出発地点と目的地点の緯度経度を定義
    const startLat = 35.6895; // 出発地点の緯度 (例: 東京)
    const startLon = 139.6917; // 出発地点の経度 (例: 東京)
    const endLat = 35.6586; // 目的地点の緯度 (例: 東京タワー)
    const endLon = 139.7454; // 目的地点の経度 (例: 東京タワー)
    let propertyKeyHeight = "S12_009";//駅データの年数を変えるためのプロパティーを変更するための変数
    let propertyKey1 = "S12_006";//駅データの年数を変えるためのプロパティーを変更するための変数
    let propertyKey2 = "S12_007";//駅データの年数を変えるためのプロパティーを変更するための変数
    let maxValue;//駅データのプロパティ最大値確認
    let minValue = 6;//駅データのプロパティ最小値は常に6
    const pg = new THREE.PlaneGeometry(120, 50);
    const pm = new THREE.MeshBasicMaterial({ color: 0x808080, side: THREE.DoubleSide });
    const plane = new THREE.Mesh(pg, pm); plane.rotation.x = -Math.PI / 2;
    plane.position.set(-10, 0, 80);
    scene.add(plane);
    //中心座標を表すobject
    const geometry2 = new THREE.CylinderGeometry(0.2, 0.2, 0.4, 32);
    const material2 = new THREE.MeshBasicMaterial({ color: 0xff0000 });
    let cylinder = new THREE.Mesh(geometry2, material2);
    cylinder.position.set(0.48421333333408256, 0.5, -3.0365134467951975);   // 東京タワーの緯度経度をthree.js座標に変えたもの
    cylinder.name = "cylinder";
    scene.add(cylinder);

    // ズームレベルに応じて半径を更新する関数
    function updateCylinderRadius(zoom) {

      const heightMapping = {
        19: 0.2,   // zoom 19で高さが大きい
        16: 0.05,
        13: 0.05,
        10: 0.05,
        7: 0.01    // zoom 7で最小の高さ
      };

      const radius = heightMapping[zoom] || 0.01; // マッピング外ズーム時のデフォルト値
      // 古いジオメトリを削除
      cylinder.geometry.dispose();
      // 新しいジオメトリを作成し、適用
      cylinder.geometry = new THREE.CylinderGeometry(radius, radius, 0.4, 32);
    }

    // タイルをロードする関数
    function loadOSMTile(x, y, z) {
      const subdomain = ['a', 'b', 'c'][Math.floor(Math.random() * 3)];
      const url = osmUrl.replace('{s}', subdomain).replace('{z}', z).replace('{x}', x).replace('{y}', y);

      loader.load(url, function (texture) {
        const geometry = new THREE.PlaneGeometry(1, 1);
        const material = new THREE.MeshStandardMaterial({ map: texture });
        const tile = new THREE.Mesh(geometry, material);
        tile.rotation.x = -Math.PI / 2;
        tile.position.set((x - 2 - tileOriginX), 0.01, (y - 5 - tileOriginY));
        // tile.receiveShadow = true;  // 建物が影を受ける設定
        // タイルを配列に追加
        tiles.push(tile);
        //scene.add(tile);
        group.add(tile);

      }, undefined, function (err) {
        console.error('タイルの読み込みに失敗しました:', err);
      });
    }



    // 緯度経度をタイル座標に変換する関数
    function lonLatToTileXY(lon, lat, zoom) {
      const tileCount = Math.pow(2, zoom);
      const x = ((lon + 180) / 360) * tileCount;
      const y = (1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * tileCount;
      return { x, y };
    }

    // 緯度経度をThree.jsのシーン座標に変換する関数
    function convertCoordinates(lon, lat) {
      const tile = lonLatToTileXY(lon, lat, zoom);

      // マップの中心となるタイルを基準にオフセットを計算
      const xOffset = tile.x - tileOriginX;
      const yOffset = tile.y - tileOriginY;

      // Three.js の空間でのタイルの大きさに合わせたスケールファクター (タイル幅の0.5単位)
      const tileScale = 0.7;

      // スケールを適用して座標を計算
      const x = (tile.x - 2.5 - tileOriginX);
      const z = (tile.y - 5.5 - tileOriginY);


      return { x, z };
    }
    // Three.jsのシーン座標を緯度経度に戻す関数
    function convertSceneToLatLon(x, z, zoom) {
      // Three.jsの座標に適用されていたスケーリングを逆にする
      const tileScale = 0.7;

      // Three.jsのシーン座標をタイル座標に戻す
      const tileX = (x + tileOriginX) + 2.5;
      const tileY = (z + tileOriginY) + 5.5;

      // タイル座標から緯度経度を計算する
      const lonLat = tileXYToLonLat(tileX, tileY, zoom);

      return { lon: lonLat.lon, lat: lonLat.lat };
    }

    // これは `lonLatToTileXY` の逆変換を行う関数です
    function tileXYToLonLat(tileX, tileY, zoom) {
      const n = Math.PI - 2 * Math.PI * tileY / Math.pow(2, zoom);
      const lon = tileX / Math.pow(2, zoom) * 360 - 180;
      const lat = (180 / Math.PI) * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));

      return { lon, lat };
    }

    // タイル座標から緯度経度に変換する関数
    function tileToLonLat(x, y, zoom) {
      const n = Math.pow(2, zoom);
      const lon = ((x / n) * 360 - 180);
      const lat = Math.atan(Math.sinh(Math.PI * (1 - (2 * y) / n))) * (180 / Math.PI);
      return { lon, lat };
    }
    //建物表示
    function loadBuildings(bounds) {
      // Overpass APIクエリ (指定範囲内の建物を取得)
      const query = `
        [out:json];
        (way["building"](${bounds.south},${bounds.west},${bounds.north},${bounds.east});
         relation["building"](${bounds.south},${bounds.west},${bounds.north},${bounds.east}););
        out tags geom;`;

      const url = "https://overpass-api.de/api/interpreter?data=" + encodeURIComponent(query);

      fetch(url)
        .then(response => response.json())
        .then(data => {
          // 建物データをThree.jsオブジェクトとして追加
          data.elements.forEach(element => {
            if (element.type === "way" && element.geometry) {
              const shape = new THREE.Shape();

              // 建物のポリゴン座標をThree.js座標に変換
              element.geometry.forEach((point, index) => {
                const coords = convertCoordinates(point.lon, point.lat);
                if (index === 0) {
                  shape.moveTo(coords.x, -coords.z);
                } else {
                  shape.lineTo(coords.x, -coords.z);
                }
              });

              // 建物の高さを取得
              const height = getBuildingHeight(element.tags);

              // ポリゴンを3Dオブジェクトに変換
              const geometry = new THREE.ExtrudeGeometry(shape, { depth: height, bevelEnabled: false });
              const material = new THREE.MeshStandardMaterial({ color: 0x999999, transparent: true, side: THREE.DoubleSide });

              const building = new THREE.Mesh(geometry, material);
              building.rotation.x = -Math.PI / 2; //x中心に回転

              builds.push(building);
              // 建物のジオメトリから中心を計算
              const boundingBox = new THREE.Box3().setFromObject(building);
              const buildingCenter = new THREE.Vector3();
              boundingBox.getCenter(buildingCenter);

              // プレイヤーとの距離を計算
              const distance = cameraContainer.position.distanceTo(buildingCenter);
              // シーンに追加
              scene.add(building);
            }
          });
        })
        .catch(error => console.error('Error loading buildings:', error));
    }

    // 建物の高さを取得する関数
    function getBuildingHeight(tags) {
      if (tags.height) {
        return parseFloat(tags.height * 0.1); // OSMのheightタグを使用
      } else if (tags["building:levels"]) {
        const levels = parseInt(tags["building:levels"], 10);
        return levels * 0.1; // 1階を0.1メートルとして換算
      } else {
        return 0.1; // デフォルトの高さ（0.1メートル）を使用
      }
    }

    // 地図範囲を取得して建物をロード
    function updateBuildings(center, zoom) {
      // 地図範囲を計算
      const tileNW = tileToLonLat(tileOriginX - 10, tileOriginY - 10, zoom); // 左上
      const tileSE = tileToLonLat(tileOriginX + 10, tileOriginY + 5, zoom); // 右下

      const bounds = {
        north: tileNW.lat,
        south: tileSE.lat,
        east: tileSE.lon,
        west: tileNW.lon,
      };

      loadBuildings(bounds);
    }
    let loadingSprite;
    let loadingTextCanvas;
    let loadingTextContext;
    let darkOverlay;

    function createLoadingMessage() {
      // Canvasを作成してテキストを描画
      loadingTextCanvas = document.createElement('canvas');
      loadingTextCanvas.width = 1024;  // 大きなキャンバス
      loadingTextCanvas.height = 256;  // 高さも調整
      loadingTextContext = loadingTextCanvas.getContext('2d');

      // フォントサイズを大きくしてテキストを描画
      loadingTextContext.fillStyle = 'white';
      loadingTextContext.font = '80px Arial';  // フォントサイズを大きく
      loadingTextContext.fillText('ロード中...', 10, 150);  // 位置を調整

      // Canvasをテクスチャに変換
      const texture = new THREE.CanvasTexture(loadingTextCanvas);
      const material = new THREE.SpriteMaterial({ map: texture });

      // Spriteを作成
      loadingSprite = new THREE.Sprite(material);
      loadingSprite.position.set(0, 2, -10);  // VR空間内で表示する位置を調整
      loadingSprite.scale.set(16, 4, 2);  // 文字のスケールを調整して大きく

      scene.add(loadingSprite);  // シーンに追加

      // 画面全体を暗くするためのオーバーレイを作成
      const overlayGeometry = new THREE.PlaneGeometry(40, 40);  // 画面全体を覆うような大きさに調整
      const overlayMaterial = new THREE.MeshBasicMaterial({
        color: 0x000000,  // 黒
        opacity: 0.5,  // 半透明
        transparent: true
      });
      darkOverlay = new THREE.Mesh(overlayGeometry, overlayMaterial);
      darkOverlay.position.set(0, 0, -20);  // カメラの前に配置
      scene.add(darkOverlay);  // シーンに追加
    }

    // 読み込み完了後に非表示にする
    function hideLoadingMessage() {
      if (loadingSprite) {
        scene.remove(loadingSprite);  // シーンから削除
      }
      if (darkOverlay) {
        scene.remove(darkOverlay);  // 画面を暗くしているオーバーレイを削除
      }
    }
    // zoomレベルに応じて中心座標の円柱の半径を設定
    function calculateRadius(zoom) {
      // zoomレベルに対応する半径を設定
      const radiusMapping = {
        19: 0.05,
        16: 0.01,
        13: 0.01,
        10: 0.01,
        7: 0.001
      };

      // zoomレベルに基づく半径を返す
      return radiusMapping[zoom] || 0.1;  // 対応する値がなければ最小の0.1を返す
    }
    function getHeightBasedOnZoom(zoom) {
      const heightMapping = {
        19: 0.00001,   // zoom 19で高さが大きい
        16: 0.00001,
        13: 0.00001,
        10: 0.00001,
        7: 0.00001    // zoom 7で最小の高さ
      };
      return heightMapping[zoom];  // 対応する値がなければ最小の1を返す
    }
    function calculatePinSize(zoom) {
      let size;
      if (zoom > 12) {
        size = 0.002;
      } else size = 0.002
      return size;
    }
    // テキストとデータのグループ作成
    const group = new THREE.Group();
    function loadGeoJson(url, propertyKeyHeight, propertyKeyName1, propertyKeyName2) {
      // ロード中メッセージを表示
      createLoadingMessage();
      // GeoJSONファイルをロードしてピンを再表示
      fetch(url)
        .then(response => response.json())  // GeoJSONファイルをJSONとして読み込む
        .then(geojson => {
          let instanceCount = 0;  // 描画する円柱の数を取得
          let propertyConfirmation = geojson.features[0].properties; // 最大値を求めるためにgeojsonのプロパティを取得
          // 最大値を求める
          maxValue = Object.keys(propertyConfirmation).length - 2;//-2は同じ数値があるため


          const radius = calculateRadius(zoom);
          const baseHeight = getHeightBasedOnZoom(zoom);  // 基本の高さを設定
          const instancedGeometry = new THREE.CylinderGeometry(radius, radius, 1, 16); // 高さは後でスケーリング
          const instancedMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });




          geojson.features.forEach((feature, index) => {
            //console.log(JSON.stringify(feature, null, 2));
            const [lon, lat] = feature.geometry.coordinates[0];

            if (isWithinTileBounds(lon, lat) && feature.properties[propertyKeyName1] == 1 && feature.properties[propertyKeyName2] == 1) {
              instanceCount++;
            };
          });
          // InstancedMeshを作成
          const instancedMesh = new THREE.InstancedMesh(instancedGeometry, instancedMaterial, instanceCount);
          lines.push(instancedMesh);
          scene.add(instancedMesh);
          instanceCount = -1;
          geojson.features.forEach((feature, index) => {

            //console.log(JSON.stringify(feature, null, 2));
            const [lon, lat] = feature.geometry.coordinates[0];
            const basePosition = convertCoordinates(lon, lat);
            const height = feature.properties[propertyKeyHeight] * baseHeight;  // 高さをデータに基づいて設定

            const matrix = new THREE.Matrix4();
            matrix.makeTranslation(basePosition.x, height / 2, basePosition.z); // 基本位置に高さを設定
            matrix.scale(new THREE.Vector3(1, height, 1)); // 高さをスケーリングで調整
            if (isWithinTileBounds(lon, lat) && feature.properties[propertyKeyName1] == 1 && feature.properties[propertyKeyName2] == 1) {
              instanceCount++;
              instancedMesh.setMatrixAt(instanceCount, matrix); // 各インスタンスの位置とスケールを設定
              // テキストを描画するためのキャンバスを作成
              const canvas1 = document.createElement('canvas');
              const context1 = canvas1.getContext('2d');
              context1.font = '30px Arial';
              context1.fillStyle = 'red';
              context1.fillText(feature.properties[propertyKeyHeight].toString(), 10, 50); // 高さのテキスト

              // CanvasTextureを作成し、Spriteを作成
              const texture1 = new THREE.CanvasTexture(canvas1);
              const spriteMaterial1 = new THREE.SpriteMaterial({ map: texture1 });
              const sprite1 = new THREE.Sprite(spriteMaterial1);
              sprite1.position.set(basePosition.x, height + 0.1, basePosition.z); // 円柱の上に配置

              // もう一つのテキストを描画するためのキャンバスを作成
              const canvas2 = document.createElement('canvas');

              const context2 = canvas2.getContext('2d');
              context2.font = '30px Arial';
              context2.fillStyle = 'blue';
              context2.fillText(feature.properties.S12_001 + "駅," + feature.properties.S12_003, 10, 50); // 名前のテキスト

              // CanvasTextureを作成し、Spriteを作成
              const texture2 = new THREE.CanvasTexture(canvas2);
              const spriteMaterial2 = new THREE.SpriteMaterial({ map: texture2 });
              const sprite2 = new THREE.Sprite(spriteMaterial2);
              sprite2.position.set(basePosition.x, height + 0.25, basePosition.z); // 名前を配置
              if (zoom >= 16) {
                group.add(sprite1);
                group.add(sprite2);
                lines.push(sprite1);
                lines.push(sprite2);
              }
            };
          });
          console.log("GeoJSONのデータをロードしました");

          hideLoadingMessage();  // エラーが発生した場合にも非表示にする
          group.add(instancedMesh);
          scene.add(group);
          // グループ内のすべてのMeshを判定対象に追加
          group.children.forEach(child => {
            if (child.isMesh) {
              groupsToIntersect.push(child); // メッシュを配列に追加
            }
          });

          console.log(group);
        })
        .catch(error => {
          console.error("GeoJSONの読み込みに失敗しました:", error);
        });
    }
    function incrementPropertyKey(baseKey, increment) {
      let parts = baseKey.split('_'); // "_" で分割
      let prefix = parts[0] + '_'; // "S12_"
      let numberPart1 = parts[1];   // "009"
      let numberPart2 = parseInt(numberPart1, 10); // 文字列の "009" を整数に変換
      numberPart2 += increment; // 増加させる

      console.log(prefix + numberPart2.toString().padStart(3, '0'));
      return prefix + numberPart2.toString().padStart(3, '0'); // 3桁でゼロ埋めし、戻り値を返す
    }
    function decrementPropertyKey(baseKey, increment) {
      let parts = baseKey.split('_'); // "_" で分割
      let prefix = parts[0] + '_'; // "S12_"
      let numberPart1 = parts[1];   // "009"
      let numberPart2 = parseInt(numberPart1, 10); // 文字列の "009" を整数に変換
      numberPart2 -= increment; // 減少させる
      return prefix + numberPart2.toString().padStart(3, '0'); // 3桁でゼロ埋めし、戻り値を返す
    }


    // タイルの範囲内に座標があるかを確認する関数
    function isWithinTileBounds(lon, lat) {
      const tileNW = tileToLonLat(tileOriginX - 10, tileOriginY - 10, zoom); // 左上
      const tileSE = tileToLonLat(tileOriginX + 10, tileOriginY + 5, zoom); // 右下

      return (
        lon >= tileNW.lon && lon <= tileSE.lon && // 経度が範囲内
        lat <= tileNW.lat && lat >= tileSE.lat    // 緯度が範囲内
      );
    }
    //地図を表示
    function map() {
      //地図中心座標
      if (coordinates2 == undefined) {
        centerTile = lonLatToTileXY(endLon, endLat, zoom);
        tileOriginX = Math.floor(centerTile.x) - 2;
        tileOriginY = Math.floor(centerTile.y) - 2;
      } else {
        //マーカーの座標を経度緯度に変換して保持するcoordinatesを更新
        if (marker5 == undefined) { } else if (marker5.name == "cylinder") {
          coordinates2 = convertSceneToLatLon(marker5.position.x, marker5.position.z, zoom);

        }

        centerTile = lonLatToTileXY(coordinates2.lon, coordinates2.lat, zoom);
        tileOriginX = Math.floor(centerTile.x) - 2;
        tileOriginY = Math.floor(centerTile.y) - 2;
      }

      for (let x = tileOriginX - 10; x < tileOriginX + 10; x++) {
        for (let y = tileOriginY - 10; y < tileOriginY + 5; y++) {
          loadOSMTile(x, y, zoom);
        }
      }
      if (!hasExecuted) {
        // ここに実行したいコードを書く
        coordinates2 = convertSceneToLatLon(cylinder.position.x, cylinder.position.z, zoom);
        // フラグを更新
        hasExecuted = true;
      }


      let marker3 = convertCoordinates(coordinates2.lon, coordinates2.lat);
      cylinder.position.set(marker3.x, 0.5, marker3.z);


      coordinates2 = convertSceneToLatLon(cylinder.position.x, cylinder.position.z, zoom);
      marker5 = undefined;
      updateCylinderRadius(zoom); // 例えばズームレベル2に変更


      // シェープファイルのパスを指定（.zip形式）
      loadGeoJson('S12-23_NumberOfPassengers.geojson', propertyKeyHeight, propertyKey1, propertyKey2);

      //zoomが一番拡大されたときのみ建物を表示
      if (zoom > 18) {
        // 中心座標変更時に呼び出す
        updateBuildings({ lon: centerLon, lat: centerLat }, zoom);
      }

    }
    map();
    //建物を半透明にする
    function updateBuildingTransparency(playerPosition, buildings, radius) {
      buildings.forEach(building => {
        // 建物のジオメトリから中心を計算
        const boundingBox = new THREE.Box3().setFromObject(building);
        const buildingCenter = new THREE.Vector3();
        boundingBox.getCenter(buildingCenter);

        // プレイヤーとの距離を計算
        const distance = playerPosition.distanceTo(buildingCenter);

        if (distance < radius) {
          building.material.opacity = 0.5;  // 範囲内: 半透明
        } else {
          building.material.opacity = 1.0;  // 範囲外: 不透明
        }
      });
    }
    // タイル、ピン、経路、建物を削除する関数
    function clear() {
      tiles.forEach(tile => {
        scene.remove(tile); // シーンからタイルを削除
      });
      tiles = []; // 配列をクリア
      pins.forEach(pin => {
        scene.remove(pin);  // シーンからピンを削除
        pins = [];
      });
      pins = []; // 配列をクリア
      lines.forEach(line => {
        scene.remove(line); // シーンから経路を削除
      });
      lines = []; // 配列をクリア
      builds.forEach(build => {
        scene.remove(build); // シーンから建物を削除
      });
      builds = []; // 配列をクリア
      console.log(group);

      // グループの子を全削除
      group.children.forEach(child => {
        if (child.isMesh) {
          // シーンから削除
          scene.remove(child);

          // 配列から削除
          const index = groupsToIntersect.indexOf(child);
          if (index !== -1) {
            groupsToIntersect.splice(index, 1);
          }
        }

        // メモリ解放のためにジオメトリとマテリアルを破棄
        if (child.geometry) child.geometry.dispose();
        if (child.material) child.material.dispose();
      });
      group.clear();

      scene.remove(group);

      console.log(group);
    }
    // 毎フレーム時に実行されるループイベント
    function tick() {
      if (isRearView) {
        renderer.xr.enabled = isRearView;
        // 後方カメラの映像をVR内HUDに表示
        cameraContainer2.rotation.x = 0;//元に戻す回転
        renderer.render(scene, camera2);  // メインカメラでVRシーンを描画
        // 後方カメラの映像をVR内HUDに表示
        renderer.xr.enabled = !isRearView;
        renderer.setRenderTarget(renderTarget);  // 後方カメラ用のレンダリングターゲットをセット
        renderer.render(scene, camera);  // 後方カメラでVRシーンを描画
        renderer.setRenderTarget(null);  // ターゲットを元に戻す
        updateHUDPosition();  // HUDの位置を更新

      } else {
        renderer.xr.enabled = !isRearView;
        cameraContainer.rotation.x = 0;  // 元に戻す回転
        renderer.render(scene, camera);  // メインカメラでVRシーンを描画

        renderer.xr.enabled = isRearView;
        // 後方カメラの映像をVR内HUDに表示
        renderer.setRenderTarget(renderTarget);  // 後方カメラ用のレンダリングターゲットをセット
        renderer.render(scene, camera2);  // 後方カメラでVRシーンを描画
        renderer.setRenderTarget(null);  // ターゲットを元に戻す
        updateHUDPosition();  // HUDの位置を更新


      }
    }


    // リサイズ処理
    window.addEventListener("resize", onResize);
    function onResize() {
      if (!renderer.xr.getSession()) { // Only resize if not in VR
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
    }

    /* ----コントローラー設定----- */

    // // コントローラーイベントの設定
    function onSelectStart() {
      this.userData.isSelecting = true;
    }
    function onSelectEnd() {
      this.userData.isSelecting = false;
    }
    function onButtonDown() {
      this.userData.isSelecting = true;
    }
    function onButtonUp() {
      this.userData.isSelecting = false;
    }
    function onSqueezeStart() {
      this.userData.isSelecting = true;
    }
    function onSqueezeEnd() {
      this.userData.isSelecting = false;
    }
    //コントローラー取得
    controller1 = renderer.xr.getController(0);
    controller1.addEventListener('selectstart', onSelectStart);//トリガー
    controller1.addEventListener('selectend', onSelectEnd);
    controller1.addEventListener('squeezestart', onSqueezeStart);//スクイーズ
    controller1.addEventListener('squeezeend', onSqueezeEnd);
    controller1.addEventListener('connected', (event) => {
      if ('gamepad' in event.data) {//接続した際にコントローラの情報を渡す
        if ('axes' in event.data.gamepad) {
          controller1.gamepad = event.data.gamepad;
        }
      }
    });
    controller2 = renderer.xr.getController(1);
    controller2.addEventListener('selectstart', onSelectStart);//トリガー
    controller2.addEventListener('selectend', onSelectEnd);
    controller2.addEventListener('squeezestart', onSqueezeStart);//スクイーズ
    controller2.addEventListener('squeezeend', onSqueezeEnd);
    controller2.addEventListener('connected', (event) => {
      if ('gamepad' in event.data) {
        if ('axes' in event.data.gamepad) {
          controller2.gamepad = event.data.gamepad;
        }
      }
    });

    //コントローラーモデルを取得
    const controllerModelFactory = new XRControllerModelFactory();
    controllerGrip1 = renderer.xr.getControllerGrip(0);
    controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));

    controllerGrip2 = renderer.xr.getControllerGrip(1);
    controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));

    // コントローラーに userData プロパティを追加して id を設定する
    controller1.userData.id = 0;
    controller2.userData.id = 1;
    //コントローラーから出る光線の作成				
    const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]);
    const line1 = new THREE.Line(geo);
    const line2 = new THREE.Line(geo);
    line1.name = 'line';
    line1.scale.z = 5;
    line2.name = 'line';
    line2.scale.z = 5;
    controller1.add(line1.clone());
    controller2.add(line2.clone());

    //コントローラ機能


    // Raycasterを作成
    let raycaster = new THREE.Raycaster();
    let tempMatrix = new THREE.Matrix4(); // コントローラーの位置と向きを取得するための一時行列
    var groupsToIntersect = [cylinder];//レイと交差判定できるobjectを代入
    // レイと交差しているシェイプの取得
    function getIntersections(controller) {
      tempMatrix.identity().extractRotation(controller.matrixWorld);
      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
      return raycaster.intersectObjects(groupsToIntersect, true);
    }
    var groupsToIntersect2 = [cylinder];//レイと交差判定できるobjectを代入
    // レイと交差しているシェイプの取得
    function getIntersections2(controller) {
      tempMatrix.identity().extractRotation(controller.matrixWorld);
      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
      return raycaster.intersectObjects(groupsToIntersect2, true);
    }
    let builds2 = [];
    //選択した建物をコピー
    // x座標を管理するカウンター
    let xOffset = -5;
    let zOffset = -2;
    // 複製されたデータを管理する配列
    let copiedData = [];
    let maxCopies = 4; // 最大複製数
    let gridSize = 4; // 1行に並べるデータの数 (正方形の幅)
    let spacing = 25; // 各データの間隔
    let lastRemovedPositions = []; // 削除されたデータの位置をリストで管理

    function copyData(originalData) {
      if (copiedData.length >= maxCopies) {
        console.log("最大複製数に達しています");
        return; // これ以上複製しない
      }

      // 独立したCanvasを作成
      const canvasCopy = document.createElement('canvas');
      canvasCopy.width = 500; // 必要に応じて設定
      canvasCopy.height = 250;
      const contextCopy = canvasCopy.getContext('2d');

      // オリジナルのCanvas内容をコピー
      contextCopy.drawImage(canvas4, 0, 0); // canvas4が元のCanvasの場合

      // 独立したTextureとSpriteを作成
      const textureCopy = new THREE.CanvasTexture(canvasCopy);
      const spriteMaterialCopy = new THREE.SpriteMaterial({
        map: textureCopy,
        side: THREE.DoubleSide,
        depthTest: false,
        depthWrite: false,
      });
      const copiedSprite = new THREE.Sprite(spriteMaterialCopy);
      copiedSprite.scale.set(10, 10, 0);

      // データオブジェクトを複製
      const clonedData = originalData.clone();

      // 配置位置を決定
      let position;
      if (lastRemovedPositions.length > 0) {
        // 削除された位置を優先して配置
        position = lastRemovedPositions.pop();
      } else {
        // グリッド上の位置を計算（横一列に並べる）
        const index = copiedData.length;
        const col = index % gridSize; // 列 (X軸方向)
        // 左に表示をずらすためのオフセットを追加
        const offsetX = -spacing * (gridSize / 2); // グリッドの中心から左にずらす
        position = {
          x: col * spacing + offsetX,  // 列方向の間隔
          y: 0,
          z: 90,  // Z軸の固定位置（奥行き）
        };
      }

      // 配置位置をデータに追加
      clonedData.position.set(position.x, position.y, position.z);
      copiedSprite.position.set(position.x, 10, position.z - 10); // 表示したい位置に移動

      // コピーされたデータを配列に追加（スプライトも含む）
      copiedData.push({ data: clonedData, sprite: copiedSprite });
      clonedData.children.forEach(child => {
        if (child.isMesh) {
          groupsToIntersect2.push(child); // メッシュを配列に追加
        }
      });

      // シーンに追加
      scene.add(clonedData);
      scene.add(copiedSprite);

      // デバッグ用にコンソールで表示
      console.log("コピーされたデータ:", clonedData);
    }

    function removeData(data) {
      // データに関連付けられたスプライトを見つける
      const dataIndex = copiedData.findIndex(item => item.data === data);

      if (dataIndex > -1) {
        // スプライトを取得して削除
        const associatedSprite = copiedData[dataIndex].sprite;
        scene.remove(associatedSprite);

        // 配列からデータとスプライトを削除
        copiedData.splice(dataIndex, 1);
      }

      // シーンからデータを削除
      scene.remove(data);

      // 子オブジェクト（メッシュ）の処理
      data.children.forEach(child => {
        if (child.isMesh) {
          // groupsToIntersect2 から削除
          const childIndex = groupsToIntersect2.indexOf(child);
          if (childIndex > -1) {
            groupsToIntersect2.splice(childIndex, 1);
          }

          // メモリ解放のためジオメトリとマテリアルを破棄
          if (child.geometry) child.geometry.dispose();
          if (child.material) child.material.dispose();
        }
      });

      // 削除された位置をリストに記録
      lastRemovedPositions.push(data.position.clone());

      // デバッグ用ログ
      console.log("削除されたデータ:", data);
    }
    // グループの親を探す関数
    function findParentGroup(object) {
      let parent = object.parent;
      console.log("グループの状態:", parent);
      while (parent) {
        if (parent.isGroup) {
          console.log("c");
          return parent;
        }
        parent = parent.parent;
      }
      return null;
    }



    let hasZoomed1 = true; // ボタンを押した状態を追跡するフラグ
    let hasZoomed2 = true; // ボタンを押した状態を追跡するフラグ

    function handleController(controller) {
      const userData = controller.userData;
      const intersections = getIntersections(controller);//当たり判定
      const intersections2 = getIntersections2(controller);//当たり判定
      let controllerData = controller.gamepad;
      console.log(userData.isSelecting)
      if(controllerData){
        console.log("a");
      }
      if (controllerData!==undefined) {
        if (controllerData.buttons[0].pressed == true) {//トリガーボタン
          if (userData.id == 0) {
            line1.material.color.set(0xff0000); // 赤色に設定

            if (intersections2.length > 0) {
              const intersection = intersections2[0];
              const object = intersection.object;
              // すでにオブジェクトがアタッチされている場合は何もしない
              if (controller.userData.selected) {
                return;
              }
              if (object.name == "cylinder") {
                // 動かす前の座標を保存
                const originalPosition = { x: object.position.x, y: object.position.y, z: object.position.z };

                // オブジェクトの座標をコントローラーにアタッチ
                controller.attach(object);

                // コントローラーのユーザーデータに選択されたオブジェクトを保存
                controller.userData.selected = object;
              } else {
                if (hasZoomed1) {
                  const groupToCopy = findParentGroup(object);

                  if (groupToCopy) {
                    removeData(groupToCopy);
                  }
                  hasZoomed1 = false;
                }
              }
            }
          } else {
            line2.material.color.set(0xff0000);
            if (intersections.length > 0) {
              const intersection = intersections[0];
              const object = intersection.object;
              // すでにオブジェクトがアタッチされている場合は何もしない
              if (controller.userData.selected) {
                return;
              }
              if (object.name == "cylinder") {
                // 動かす前の座標を保存
                const originalPosition = { x: object.position.x, y: object.position.y, z: object.position.z };

                // オブジェクトの座標をコントローラーにアタッチ
                controller.attach(object);

                // コントローラーのユーザーデータに選択されたオブジェクトを保存
                controller.userData.selected = object;
              } else {
                if (hasZoomed2) {
                  console.log("a");
                  const groupToCopy = findParentGroup(object);
                  console.log(object);
                  if (groupToCopy) {

                    console.log("b");
                    copyData(groupToCopy);
                  }
                  hasZoomed2 = false;
                }
              }
            }
          }
        } else if (controllerData.buttons[1].pressed == true) {//スクイーズボタン
          if (userData.id == 0) {
            line1.material.color.set(0xff0000); // 赤色に設定
            if (hasZoomed1 && zoom < 19) {//地図拡大
              zoom += 3;
              clear();
              map();
              hasZoomed1 = false;
            }
          } else {
            line2.material.color.set(0xff0000); // 赤色に設定
            if (hasZoomed2 && zoom > 7) {//地図縮小
              zoom -= 3;
              clear();
              map();
              hasZoomed2 = false;
            }
          }
        }
        else if (controllerData.buttons[2].pressed == true) {//不明
          console.log("2");
        } else if (controllerData.buttons[3].pressed == true) {//スティック押し込み
          console.log("3");
        } else if (controllerData.buttons[4].pressed == true) {//xaボタン
          console.log("4");
          if (userData.id == 0) {
            if (hasZoomed1) {//カメラ切り替え
              hudGroup.visible = !hudGroup.visible; // 表示・非表示を切り替え
              hasZoomed1 = false;
            }
          } else {
            if (hasZoomed2) {//カメラ切り替え
              isRearView = !isRearView;
              hasZoomed2 = false;
            }
          }
        } else if (controllerData.buttons[5].pressed == true) {//yb
          console.log("5");
          if (userData.id == 0) {
            if (hasZoomed1) {
              let parts = propertyKeyHeight.split('_'); // "_" で分割
              let prefix = parts[0] + '_'; // "S12_"
              let numberPart1 = parts[1];   // "009"
              let numberPart2 = parseInt(numberPart1, 10); // 文字列の "009" を整数に変換
              if (numberPart2 < maxValue) {
                propertyKeyHeight = incrementPropertyKey(propertyKeyHeight, 4);
                propertyKey1 = incrementPropertyKey(propertyKey1, 4);
                propertyKey2 = incrementPropertyKey(propertyKey2, 4);
                clear();
                map();

                year++; // 年をインクリメント
                // 新しい年をキャンバスに描画
                context3.clearRect(0, 0, canvas3.width, canvas3.height); // 以前の描画をクリア

                context4.clearRect(0, 0, canvas4.width, canvas4.height); // 以前の描画をクリア
                context3.fillText(year + "年", 10, 50); // 新しい年を描画
                context4.fillText(year + "年", 0, 100); // 新しい年を描画
                // テクスチャを更新
                texture3.needsUpdate = true; // テクスチャの更新を反映させる
                texture4.needsUpdate = true; // テクスチャの更新を反映させる
              }
              hasZoomed1 = false;
            }
          } else {
            if (hasZoomed2) {
              let parts = propertyKey1.split('_'); // "_" で分割
              let prefix = parts[0] + '_'; // "S12_"
              let numberPart1 = parts[1];   // "006"
              let numberPart2 = parseInt(numberPart1, 10); // 文字列の "006" を整数に変換
              if (numberPart2 > minValue) {
                propertyKeyHeight = decrementPropertyKey(propertyKeyHeight, 4);
                propertyKey1 = decrementPropertyKey(propertyKey1, 4);
                propertyKey2 = decrementPropertyKey(propertyKey2, 4);
                clear();
                map();
                year--; // 年をインクリメント
                // 新しい年をキャンバスに描画
                context3.clearRect(0, 0, canvas3.width, canvas3.height); // 以前の描画をクリア
                context4.clearRect(0, 0, canvas4.width, canvas4.height); // 以前の描画をクリア
                context3.fillText(year + "年", 10, 50); // 新しい年を描画

                context4.fillText(year + "年", 0, 100); // 新しい年を描画


                // テクスチャを更新
                texture3.needsUpdate = true; // テクスチャの更新を反映させる

                texture4.needsUpdate = true; // テクスチャの更新を反映させる
              }
              hasZoomed2 = false;
            }
          }
        } else if (controllerData.buttons[6].pressed == true) {//不明
          console.log("6");
        } else if (userData.id == 0) {
          //右ボタンが離されたときの処理
          line1.material.color.set(0xffffff); hasZoomed1 = true; //白色に設定
          if (controller.userData.selected !== undefined) {
            const object = controller.userData.selected;

            object.matrix.premultiply(controller.matrixWorld);
            object.matrix.decompose(object.position, object.quaternion, object.scale);
            marker5 = object;
            scene.add(object);
            controller.userData.selected = undefined;
            if (object.name == "cylinder") {
              clear();
              map();
            }
          }
        } else if(userData.id == 1){
          //左ボタンが離されたときの処理
          line2.material.color.set(0xffffff); hasZoomed2 = true;
          if (controller.userData.selected !== undefined) {
            const object = controller.userData.selected;
            object.matrix.premultiply(controller.matrixWorld);
            object.matrix.decompose(object.position, object.quaternion, object.scale);
            marker5 = object;
            scene.add(object);
            controller.userData.selected = undefined;
            clear();
            map();
          }
        }
        controllerData = undefined;
      }
    }
    // スティック入力に基づく移動
    function updateMovement1(controller) {
      // コントローラのゲームパッドデータを取得
      const controllerData = controller.gamepad;

      if (controllerData && controllerData.axes) {
        let cameraRotation;

        if (!isRearView) {
          cameraRotation = camera.rotation;
        } else {
          cameraRotation = camera2.rotation;
        }

        const bugRotat = Math.abs(cameraRotation.x) + Math.abs(cameraRotation.z);
        let speed;
        speed = (Math.abs(controllerData.axes[2]) + Math.abs(controllerData.axes[3])) * 0.1;
        if (bugRotat > 3) {
          speed *= -1;
          cameraRotation.y *= -1;
        }
        move(cameraRotation, speed, controller);
        // 移動関数
        function move(orientation, speed, controller) {
          const direction = new THREE.Vector3(controller.gamepad.axes[2], 0, controller.gamepad.axes[3]);
          direction.applyQuaternion(new THREE.Quaternion(0, orientation.y, 0));
          // 方向ベクトルを正規化してから速度を掛け算
          direction.normalize();
          if (!isRearView) {
            cameraContainer.position.addScaledVector(direction, speed);
          } else if (isRearView) {

            cameraContainer2.position.addScaledVector(direction, speed * 2.5);
          }
        }
      }
    }

    const speeded = 0.1;
    // スティック入力に基づく移動
    function updateMovement2(controller) {
      // コントローラのゲームパッドデータを取得
      const controllerData = controller.gamepad;

      if (controllerData && controllerData.axes) {
        const joystickInput = controllerData.axes; // スティックの入力
        // スティックの入力がゼロでないかを確認
        if ((Math.abs(joystickInput[2]) > 0.1 || Math.abs(joystickInput[3]) > 0.1) && !isRearView) {
          cameraContainer.position.y -= joystickInput[2] * speeded;
          cameraContainer.position.y -= joystickInput[3] * speeded;


        } else if ((Math.abs(joystickInput[2]) > 0.1 || Math.abs(joystickInput[3]) > 0.1) && isRearView) {

          cameraContainer2.position.y -= joystickInput[2] * speeded;
          cameraContainer2.position.y -= joystickInput[3] * speeded;

        }
      }
    }



    /* ----コントローラー設定----- */

    // フラストムを生成
    const frustum = new THREE.Frustum();
    const cameraViewProjectionMatrix = new THREE.Matrix4();
    const frustum2 = new THREE.Frustum();
    const cameraViewProjectionMatrix2 = new THREE.Matrix4();

    function updateVisibleTiles() {
      // カメラのビュー投影行列を更新
      camera.updateMatrixWorld(); // ワールドマトリクスを更新
      cameraViewProjectionMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      frustum.setFromProjectionMatrix(cameraViewProjectionMatrix);
      camera2.updateMatrixWorld(); // ワールドマトリクスを更新
      cameraViewProjectionMatrix2.multiplyMatrices(camera2.projectionMatrix, camera2.matrixWorldInverse);
      frustum2.setFromProjectionMatrix(cameraViewProjectionMatrix2);

      tiles.forEach(tile => {
        // タイルのボックスを生成
        const box = new THREE.Box3().setFromCenterAndSize(tile.position, new THREE.Vector3(1, 1, 1));

        // タイルがフラストム内にあるかを確認
        if (frustum.intersectsBox(box) || frustum2.intersectsBox(box)) {
          // フラストム内の場合はシーンに追加
          if (!scene.children.includes(tile)) {
            scene.add(tile);
          }
        } else {
          // フラストム外の場合はシーンから削除
          if (scene.children.includes(tile)) {
            scene.remove(tile);
          }
        }
      });
    }
    // 初期状態でカメラコンテナの位置を記録
    let previousPosition = cameraContainer.position.clone();

    //毎フレーム実行される
    function render() {
      //カメラ切り替え
      tick();
      //スティック移動
      updateMovement1(controller1);
      updateMovement2(controller2);

      // //前方後方コントローラ切り替え
      if (isRearView) {
        cameraContainer.remove(controller1);
        cameraContainer.remove(controller2);
        cameraContainer.remove(controllerGrip1);
        cameraContainer.remove(controllerGrip2);
        cameraContainer2.add(controller1);
        cameraContainer2.add(controller2);
        cameraContainer2.add(controllerGrip1);
        cameraContainer2.add(controllerGrip2);

      } else {
        cameraContainer2.remove(controller1);
        cameraContainer2.remove(controller2);
        cameraContainer2.remove(controllerGrip1);
        cameraContainer2.remove(controllerGrip2);
        cameraContainer.add(controller1);
        cameraContainer.add(controller2);
        cameraContainer.add(controllerGrip1);
        cameraContainer.add(controllerGrip2);

      }
      //コントローラ機能
      handleController(controller1);
      handleController(controller2);
    }


    // 初回のレンダリングループの開始
    renderer.setAnimationLoop(render);

  </script>
</body>

</html>
